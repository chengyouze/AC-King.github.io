#### 题目翻译
对于一个区间 $[l,r]$，你可以选择其中一个数 $k$，然后删除 $[l,r]$ 这个区间。若 $l\leqslant k-1$ 则建立 $[l,k-1]$ 区间，若 $k+1\leqslant r$ 则建立 $[k+1,r]$ 区间。

初始有一个 $[1,n]$ 的区间，它将不断执行上述操作直到区间全部删除，给出过程中出现的所有区间，问出现的所有区间中选择的 $k$ 分别是哪些。

#### 题目翻译化简版
有 $n$ 个区间 $[l,r]$。从每个区间中选择一个数，使得选出的数为 $n$ 的排列。

#### 做题思路
由于总会有一个区间只包含一个数（也就是题目描述中游戏结束的那一轮），那么我们可以把这个区间的长度进行排序，依次求出每个区间应该选择的数。

#### 样例分析
按我的方法说下样例1的第6个点：
```
6

1 1

3 5

4 4

3 6

4 5

1 6
```

这是原样例，按我的方法将它按长度排序得：
```
6

1 1(长度为1)(选择1)

4 4(长度为1)(选择4)

4 5(长度为2)(4被选，选5)

3 5(长度为3)(4,5被选，选3)

3 6(长度为4)(3,4,5被选，选6)

1 6(长度为6)$ $(1,3,4,5,6被选，选2)
```

是不是明白了？那么放代码了

#### 题目代码
```cpp
struct k 
{
	int l,r,ans;
	bool f=0;
};//分别为区间端点l,r以及答案选择的数字还有标记
bool cmp(k a,k b)//比较长度排序
{
	if(a.r-a.l>b.r-b.l)return 0;
	if(a.r-a.l<b.r-b.l)return 1;
	return a.l<b.l;
}
void solve()
{
	int n;
	cin>>n;
	k a[n+1];
	for(int i=1;i<=n;i++)
	{
		cin>>a[i].l>>a[i].r;
	}
	sort(a+1,a+n+1,cmp);//自定义排序
	for(int i=1;i<=n;i++)
	{
		for(int j=a[i].l;j<=a[i].r;j++)//由于n很小，所以直接循环区间也不会超时
		{
			if(a[j].f==0)//如果没被选择
			{
				a[j].f=1;//打上标记
				a[i].ans=j;
				break;
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		cout<<a[i].l<<" "<<a[i].r<<" "<<a[i].ans<<endl;//输出，可以交换任意区间的输出顺序
	}
//	cout<<endl;
}
```
多组数据，代码未全。请勿copy，当心踩坑。